#include <ffigen/process/code_entity/function.hpp>
#include <ffigen/utility/exceptions.hpp>
#include <ffigen/utility/error_codes.hpp>
#include <ffigen/utility/logger.hpp>
#include <iostream>

namespace ffigen
{
    using namespace utility::logs;

    // function
    function::function(std::string const& name
      , std::string const& file
      , code_entity const& return_type
      , arguments_list_type const& arguments
      , bool is_variadic
    ) : base_type(name, file)
      , _return_type(return_type)
      , _arguments(arguments)
      , _is_variadic(is_variadic)
    {}

    void function::fill_dependents() const
    {
        _dependents.push_back(&_return_type);
        for (auto const& param_type : _arguments) {
            _dependents.push_back(&param_type);
        }
    }

    // function::generator

    //! converts
    //!
    //! int my_function(params...)
    //!
    //! to
    //!
    //! _library.my_function = [_library.int, [params...]];
    void function::generator::operator()(std::ostream & os) const
    {
        debug() << "function::generator::operator(): generating function" << std::endl;

        if (entity.is_variadic()) {
            error() << "Variadic functions not supported yet (trying to generate '"
                    << entity.name() << "')" << std::endl;
            return;
        }

        os << "_library._preload['" << entity.name() << "'] = [";
        output_preload_dependencies(os, entity);
        os << "function () {";
        newline(os);

        os << "    _library." << entity.name() << " = [";
        os << entity.return_type().ffi_reference();
        os << ", [";

        bool is_first = true;
        for (code_entity const& parameter : entity.argument_types())
        {
            if (is_first)
            {
                is_first = false;
            }
            else
            {
                os << ", ";
            }
            os << parameter.ffi_reference();
        }

        os << "]];";
        newline(os);

        os << "    _library._functions['" << entity.name() << "'] = _library." << entity.name() << ";";
        newline(os);

        os << "}];";
        newline(os);
        newline(os);

        debug() << "function::generator::operator(): finished generating function" << std::endl;
    }
}
// TODO: there are special keywords generated by node-ffi-generator. if a type is named after it, we have to skip mapping it.
//       special keywords are 'exports', 'module', 'require', '_library', ...
